function theta=Backward(T)



% DH table for the Project
% Robot dimensions (sample values)

d1 = 0.0892;
a2 = 0.425;
a3 = 0.392;

% Joint variables (these will be calculated)
theta1 = 0;
theta2 = 0;
theta3 = 0;
% DH=[        0,    pi/2,	  0.0892,	  theta(1);
%          0.425,	     0,	  0.0,	      theta(2);
%          0.392,	     0,	  0.0,         theta(3)];

dhtable = [ theta1,  d1,     0,  pi/2;
                    theta2,  0,     a2,  0;
                    theta3,  0,     a3,  0];
       
% Final homogeneous transformation matrix (sample values)
% These sample values were found using a forward kinematics calculation

Tfinal = T;
        
% Get joint values
jointValues = AdeptJV(dhtable, Tfinal);
theta = jointValues;
disp('Calculated joint values for the Viper robot manipulator.')
disp(' ')
disp(vpa(jointValues,3))
disp('Units: [radians, radians, radians, radians, radians, radians]')
% 
% jointValues = AdeptJV1(dhtable, Tfinal);
% disp('Calculated joint values for the Viper robot manipulator.')
% disp(' ')
% disp(vpa(jointValues,3))
% disp('Units: [radians, radians, radians, radians, radians, radians]')
% 
% jointValues = AdeptJV2(dhtable, Tfinal);
% disp('Calculated joint values for the Viper robot manipulator.')
% disp(' ')
% disp(vpa(jointValues,3))
% disp('Units: [radians, radians, radians, radians, radians, radians]')
% 
% jointValues = AdeptJV3(dhtable, Tfinal);
% disp('Calculated joint values for the Viper robot manipulator.')
% disp(' ')
% disp(vpa(jointValues,3))
% disp('Units: [radians, radians, radians, radians, radians, radians]')



function [jointVals] = AdeptJV(DHtbl, Tf)

%     % Define the elementary rotation and transformation matrices needed
%     theta = 0;
%     d
%     % Rotation homogeneous transformations
%     Rx(theta) = [1 0 0 0;0 cos(theta) -sin(theta) 0;0 sin(theta) cos(theta) 0;0 0 0 1];
%     Rz(theta) = [cos(theta) -sin(theta) 0 0;sin(theta) cos(theta) 0 0;0 0 1 0;0 0 0 1];
%     % Translation homogeneous transformations
%     Tx(d) = [1 0 0 d;0 1 0 0;0 0 1 0;0 0 0 1];
%     Tz(d) = [1 0 0 0;0 1 0 0;0 0 1 d;0 0 0 1];
%     
%     % Define the DH-convention composite transformation matrix
%     syms thetaz dz ax alphax
%     T(thetaz,dz,ax,alphax) = Rz(thetaz)*Tz(dz)*Tx(ax)*Rx(alphax);
%     
    % Solve for first three joint values
    
    % Extract some known values from the DH table
    d1 = double(DHtbl(1,2));
    a2 = double(DHtbl(2,3));
    a3 = double(DHtbl(3,3));
    
    % Solve for theta2&3
    
    xyz_bar = double(Tf*[0;0;0;1]);
    x_bar = xyz_bar(1);
    y_bar = xyz_bar(2);
    z_bar = xyz_bar(3);
    L = sqrt(x_bar^2 + y_bar^2);
    
    
    % Solve for theta2
    
    beta = atan2((z_bar-d1),(L));
    gamma = acos((L^2+(z_bar-d1)^2+a2^2-a3^2)/(2*a2*sqrt((L)^2+(z_bar-d1)^2)));
    theta2 = gamma+beta;
   
    
    % Solve for theta3
    theta3 = fsolve(@(theta)[cos(theta); sin(theta)]-(1/(a3^2))*[a3*cos(theta2), a3*sin(theta2); -a3*sin(theta2), a3*cos(theta2)]*[L-a2*cos(theta2);z_bar-a2*sin(theta2)-d1],0);
    
    % Solve for theta1
    theta1 = fsolve(@(theta) [cos(theta); sin(theta)]-(1/(x_bar^2+y_bar^2))*[x_bar, y_bar; y_bar, -x_bar]*[a3*cos(theta3)*cos(theta2)+a2*cos(theta2)-a3*sin(theta2)*sin(theta3); 0], 0);
    
    jointVals = [real(theta1), real(theta2),real(theta3)];

end





function [jointVals] = AdeptJV1(DHtbl, Tf)

    % Define the elementary rotation and transformation matrices needed
    syms theta d;
    % Rotation homogeneous transformations
    Rx(theta) = [1 0 0 0;0 cos(theta) -sin(theta) 0;0 sin(theta) cos(theta) 0;0 0 0 1];
    Rz(theta) = [cos(theta) -sin(theta) 0 0;sin(theta) cos(theta) 0 0;0 0 1 0;0 0 0 1];
    % Translation homogeneous transformations
    Tx(d) = [1 0 0 d;0 1 0 0;0 0 1 0;0 0 0 1];
    Tz(d) = [1 0 0 0;0 1 0 0;0 0 1 d;0 0 0 1];
    
    % Define the DH-convention composite transformation matrix
    syms thetaz dz ax alphax
    T(thetaz,dz,ax,alphax) = Rz(thetaz)*Tz(dz)*Tx(ax)*Rx(alphax);
    
    % Solve for first three joint values
    
    % Extract some known values from the DH table
    d1 = double(DHtbl(1,2));
    a2 = double(DHtbl(2,3));
    a3 = double(DHtbl(3,3));
    
    % Solve for theta2&3
    
    xyz_bar = double(Tf*[0;0;0;1]);
    x_bar = xyz_bar(1);
    y_bar = xyz_bar(2);
    z_bar = xyz_bar(3);
    L = sqrt(x_bar^2 + y_bar^2);
    
    
    % Solve for theta2
    
    beta = atan2((z_bar-d1),(L));
    gamma = acos((L^2+(z_bar-d1)^2+a2^2-a3^2)/(2*a2*sqrt((L)^2+(z_bar-d1)^2)));
    theta2 = -gamma+beta;
   
    
    % Solve for theta3
    theta3 = fsolve(@(theta)[cos(theta); sin(theta)]-(1/(a3^2))*[a3*cos(theta2), a3*sin(theta2); -a3*sin(theta2), a3*cos(theta2)]*[L-a2*cos(theta2);z_bar-a2*sin(theta2)-d1],0);
    
    % Solve for theta1
    theta1 = fsolve(@(theta) [cos(theta); sin(theta)]-(1/(x_bar^2+y_bar^2))*[x_bar, y_bar; y_bar, -x_bar]*[a3*cos(theta3)*cos(theta2)+a2*cos(theta2)-a3*sin(theta2)*sin(theta3); 0], 0);
    
    jointVals = [theta1, theta2, theta3];
end

function [jointVals] = AdeptJV2(DHtbl, Tf)

    % Define the elementary rotation and transformation matrices needed
    syms theta d;
    % Rotation homogeneous transformations
    Rx(theta) = [1 0 0 0;0 cos(theta) -sin(theta) 0;0 sin(theta) cos(theta) 0;0 0 0 1];
    Rz(theta) = [cos(theta) -sin(theta) 0 0;sin(theta) cos(theta) 0 0;0 0 1 0;0 0 0 1];
    % Translation homogeneous transformations
    Tx(d) = [1 0 0 d;0 1 0 0;0 0 1 0;0 0 0 1];
    Tz(d) = [1 0 0 0;0 1 0 0;0 0 1 d;0 0 0 1];
    
    % Define the DH-convention composite transformation matrix
    syms thetaz dz ax alphax
    T(thetaz,dz,ax,alphax) = Rz(thetaz)*Tz(dz)*Tx(ax)*Rx(alphax);
    
    % Solve for first three joint values
    
    % Extract some known values from the DH table
    d1 = double(DHtbl(1,2));
    a2 = double(DHtbl(2,3));
    a3 = double(DHtbl(3,3));
    
    % Solve for theta2&3
    
    xyz_bar = double(Tf*[0;0;0;1]);
    x_bar = xyz_bar(1);
    y_bar = xyz_bar(2);
    z_bar = xyz_bar(3);
    L = -sqrt(x_bar^2 + y_bar^2);
    
    
    % Solve for theta2
    
    beta = atan2((z_bar-d1),(L));
    gamma = acos((L^2+(z_bar-d1)^2+a2^2-a3^2)/(2*a2*sqrt((L)^2+(z_bar-d1)^2)));
    theta2 = gamma+beta;
   
    
    % Solve for theta3
    theta3 = fsolve(@(theta)[cos(theta); sin(theta)]-(1/(a3^2))*[a3*cos(theta2), a3*sin(theta2); -a3*sin(theta2), a3*cos(theta2)]*[L-a2*cos(theta2);z_bar-a2*sin(theta2)-d1],0);
    
    % Solve for theta1
    theta1 = fsolve(@(theta) [cos(theta); sin(theta)]-(1/(x_bar^2+y_bar^2))*[x_bar, y_bar; y_bar, -x_bar]*[a3*cos(theta3)*cos(theta2)+a2*cos(theta2)-a3*sin(theta2)*sin(theta3); 0], 0);
    
    jointVals = [theta1, theta2, theta3];
end

function [jointVals] = AdeptJV3(DHtbl, Tf)

%     % Define the elementary rotation and transformation matrices needed
%     syms theta d;
%     % Rotation homogeneous transformations
%     Rx(theta) = [1 0 0 0;0 cos(theta) -sin(theta) 0;0 sin(theta) cos(theta) 0;0 0 0 1];
%     Rz(theta) = [cos(theta) -sin(theta) 0 0;sin(theta) cos(theta) 0 0;0 0 1 0;0 0 0 1];
%     % Translation homogeneous transformations
%     Tx(d) = [1 0 0 d;0 1 0 0;0 0 1 0;0 0 0 1];
%     Tz(d) = [1 0 0 0;0 1 0 0;0 0 1 d;0 0 0 1];
%     
%     % Define the DH-convention composite transformation matrix
%     syms thetaz dz ax alphax
%     T(thetaz,dz,ax,alphax) = Rz(thetaz)*Tz(dz)*Tx(ax)* Rotation(alphax, 'x') ;
    
    % Solve for first three joint values
    
    % Extract some known values from the DH table
    d1 = double(DHtbl(1,2));
    a2 = double(DHtbl(2,3));
    a3 = double(DHtbl(3,3));
    
    % Solve for theta2&3
    
    xyz_bar = double(Tf*[0;0;0;1]);
    x_bar = xyz_bar(1);
    y_bar = xyz_bar(2);
    z_bar = xyz_bar(3);
    L = -sqrt(x_bar^2 + y_bar^2);
    
    
    % Solve for theta2
    
    beta = atan2((z_bar-d1),(L));
    gamma = acos((L^2+(z_bar-d1)^2+a2^2-a3^2)/(2*a2*sqrt((L)^2+(z_bar-d1)^2)));
    theta2 = -gamma+beta;
   
    
    % Solve for theta3
    theta3 = fsolve(@(theta)[cos(theta); sin(theta)]-(1/(a3^2))*[a3*cos(theta2), a3*sin(theta2); -a3*sin(theta2), a3*cos(theta2)]*[L-a2*cos(theta2);z_bar-a2*sin(theta2)-d1],0);
    
    % Solve for theta1
    theta1 = fsolve(@(theta) [cos(theta); sin(theta)]-(1/(x_bar^2+y_bar^2))*[x_bar, y_bar; y_bar, -x_bar]*[a3*cos(theta3)*cos(theta2)+a2*cos(theta2)-a3*sin(theta2)*sin(theta3); 0], 0);
    
    jointVals = [theta1, theta2, theta3];
end



%     a=[0,0.42500,0.392,0,0,0];
%     d=[0.0892,0,0,0.109,0.095,0.0825];
%     nx=T(1,1);ny=T(2,1);nz=T(3,1);
%     ox=T(1,2);oy=T(2,2);oz=T(3,2);
%     ax=T(1,3);ay=T(2,3);az=T(3,3);
%     px=T(1,4);py=T(2,4);pz=T(3,4);
%     %1th joint
%     m=d(6)*ay-py;  n=ax*d(6)-px; 
%     theta1(1,1)=atan2(real(m),real(n))-atan2(real(d(4)),real(sqrt(m^2+n^2-(d(4))^2)));
%     theta1(1,2)=atan2(real(m),real(n))-atan2(real(d(4)),real(-sqrt(m^2+n^2-(d(4))^2)));
%     %5th joint
%     theta5(1,1:2)=acos(ax*sin(theta1)-ay*cos(theta1));
%     theta5(2,1:2)=-acos(ax*sin(theta1)-ay*cos(theta1));      
%     %6th joint
%     mm=nx*sin(theta1)-ny*cos(theta1); nn=ox*sin(theta1)-oy*cos(theta1);
%     %theta6=atan2(mm,nn)-atan2(sin(theta5),0);
%     theta6(1,1:2)=atan2((mm),(nn))-atan2((sin(theta5(1,1:2))),0);
%     theta6(2,1:2)=atan2((mm),(nn))-atan2((sin(theta5(2,1:2))),0);
%     %3th joint
%     mmm(1,1:2)=d(5)*(sin(theta6(1,1:2)).*(nx*cos(theta1)+ny*sin(theta1))+cos(theta6(1,1:2)).*(ox*cos(theta1)+oy*sin(theta1))) ...
%         -d(6)*(ax*cos(theta1)+ay*sin(theta1))+px*cos(theta1)+py*sin(theta1);
%     nnn(1,1:2)=pz-d(1)-az*d(6)+d(5)*(oz*cos(theta6(1,1:2))+nz*sin(theta6(1,1:2)));
%     mmm(2,1:2)=d(5)*(sin(theta6(2,1:2)).*(nx*cos(theta1)+ny*sin(theta1))+cos(theta6(2,1:2)).*(ox*cos(theta1)+oy*sin(theta1))) ...
%         -d(6)*(ax*cos(theta1)+ay*sin(theta1))+px*cos(theta1)+py*sin(theta1);
%     nnn(2,1:2)=pz-d(1)-az*d(6)+d(5)*(oz*cos(theta6(2,1:2))+nz*sin(theta6(2,1:2)));
%     theta3(1:2,:)=acos((mmm.^2+nnn.^2-(a(2))^2-(a(3))^2)/(2*a(2)*a(3)));
%     theta3(3:4,:)=-acos((mmm.^2+nnn.^2-(a(2))^2-(a(3))^2)/(2*a(2)*a(3)));
%     %2th joint
%     mmm_s2(1:2,:)=mmm;
%     mmm_s2(3:4,:)=mmm;
%     nnn_s2(1:2,:)=nnn;
%     nnn_s2(3:4,:)=nnn;
%     s2=((a(3)*cos(theta3)+a(2)).*nnn_s2-a(3)*sin(theta3).*mmm_s2)./ ...
%         ((a(2))^2+(a(3))^2+2*a(2)*a(3)*cos(theta3));
%     c2=(mmm_s2+a(3)*sin(theta3).*s2)./(a(3)*cos(theta3)+a(2));
%     theta2=atan2(real(s2), real(c2));   
%     % check 1th 5th 6th 3th 2th joint
%     theta(1:4,1)=theta1(1,1);theta(5:8,1)=theta1(1,2);
%     theta(:,2)=[theta2(1,1),theta2(3,1),theta2(2,1),theta2(4,1),theta2(1,2),theta2(3,2),theta2(2,2),theta2(4,2)]';
%     theta(:,3)=[theta3(1,1),theta3(3,1),theta3(2,1),theta3(4,1),theta3(1,2),theta3(3,2),theta3(2,2),theta3(4,2)]';
%     theta(1:2,5)=theta5(1,1);theta(3:4,5)=theta5(2,1);
%     theta(5:6,5)=theta5(1,2);theta(7:8,5)=theta5(2,2);
%     theta(1:2,6)=theta6(1,1);theta(3:4,6)=theta6(2,1);
%     theta(5:6,6)=theta6(1,2);theta(7:8,6)=theta6(2,2); 
%     %4th joint
%     theta(:,4)=atan2(-sin(theta(:,6)).*(nx*cos(theta(:,1))+ny*sin(theta(:,1)))-cos(theta(:,6)).* ...
%      (ox*cos(theta(:,1))+oy*sin(theta(:,1))),oz*cos(theta(:,6))+nz*sin(theta(:,6)))-theta(:,2)-theta(:,3);  
end

